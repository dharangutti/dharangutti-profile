<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Celestial Events — Calendar</title>
  <style>
    body { font-family: sans-serif; margin: 2rem; }
    .event-list { display: grid; gap: 1rem; }
    .event-card { border: 1px solid #ccc; padding: 1rem; border-radius: 6px; }
    .event-title { margin: 0.5rem 0; font-size: 1.2rem; }
    .event-when, .event-location { margin: 0.25rem 0; }
    .btn { display: inline-block; margin-top: 0.5rem; padding: 0.3rem 0.6rem; background: #0078d4; color: white; text-decoration: none; border-radius: 4px; font-size: 0.9rem; }
  </style>
</head>
<body>
  <h1>Upcoming Celestial Events</h1>
  <p>Lunar eclipses, meteor showers, and planetary conjunctions — updated live from public feeds.</p>
  <section id="calendar-root" class="calendar-root" aria-live="polite"></section>

<script>
document.addEventListener('DOMContentLoaded', () => {
  Promise.all([
    fetchMeteorShowers(),
    fetchLunarEclipses(),
    fetchConjunctions()
  ]).then(results => {
    const allEvents = results.flat().filter(e => e.start >= new Date());
    allEvents.sort((a, b) => a.start - b.start);
    renderEvents(allEvents);
  }).catch(err => {
    console.warn('Failed to load celestial events:', err);
    document.getElementById('calendar-root').innerHTML = '<p>Could not load events.</p>';
  });
});

async function fetchMeteorShowers() {
  const res = await fetch('https://www.timeanddate.com/astronomy/meteor-shower/list.html');
  const html = await res.text();
  const rows = html.split('<tr>').slice(1);
  const year = new Date().getFullYear();
  const events = [];

  for (const row of rows) {
    const cols = row.split('<td>');
    if (cols.length < 6) continue;

    const name = stripTags(cols[1]);
    const dateRange = stripTags(cols[2]);
    const visibility = stripTags(cols[5]);

    const [startStr, endStr] = dateRange.split('–').map(s => s.trim());
    if (!startStr || !endStr) continue;

    const start = parseDate(year, startStr);
    const end = parseDate(year, endStr);
    if (start < new Date()) continue;

    events.push({
      title: `${name} Meteor Shower`,
      start,
      end,
      location: visibility,
      link: 'https://www.timeanddate.com/astronomy/meteor-shower/list.html'
    });
  }

  return events;
}

async function fetchLunarEclipses() {
  const res = await fetch('https://eclipse.gsfc.nasa.gov/SKYCAL/SKYCAL2025.html');
  const html = await res.text();
  const rows = html.split('<tr>');
  const events = [];

  for (const row of rows) {
    if (!row.includes('Lunar Eclipse')) continue;
    const dateMatch = row.match(/(\d{4})\s+([A-Za-z]+)\s+(\d{1,2})/);
    if (!dateMatch) continue;

    const [_, year, month, day] = dateMatch;
    const date = new Date(`${month} ${day}, ${year} 00:00 UTC`);
    if (date < new Date()) continue;

    events.push({
      title: 'Lunar Eclipse',
      start: date,
      end: new Date(date.getTime() + 3 * 60 * 60 * 1000),
      location: 'Global',
      link: 'https://eclipse.gsfc.nasa.gov/SKYCAL/SKYCAL2025.html'
    });
  }

  return events;
}

async function fetchConjunctions() {
  const res = await fetch('https://www.astropixels.com/ephemeris/sky2025/sky2025events.html');
  const html = await res.text();
  const rows = html.split('<tr>');
  const events = [];

  for (const row of rows) {
    if (!row.includes('Conjunction')) continue;
    const dateMatch = row.match(/([A-Za-z]+)\s+(\d{1,2})/);
    const bodyMatch = row.match(/([A-Za-z]+)\s+Conjunction/);
    if (!dateMatch || !bodyMatch) continue;

    const [_, month, day] = dateMatch;
    const body = bodyMatch[1];
    const year = new Date().getFullYear();
    const date = new Date(`${month} ${day}, ${year} 00:00 UTC`);
    if (date < new Date()) continue;

    events.push({
      title: `${body} Conjunction`,
      start: date,
      end: new Date(date.getTime() + 2 * 60 * 60 * 1000),
      location: 'Visible region varies',
      link: 'https://www.astropixels.com/ephemeris/sky2025/sky2025events.html'
    });
  }

  return events;
}

function stripTags(str) {
  return str.replace(/<[^>]*>/g, '').replace(/\s+/g, ' ').trim();
}

function parseDate(year, text) {
  const [monthName, day] = text.split(' ');
  return new Date(`${monthName} ${day}, ${year} 22:00 UTC`);
}

function renderEvents(events) {
  const root = document.getElementById('calendar-root');
  root.innerHTML = '';

  if (!events.length) {
    root.innerHTML = '<p>No upcoming events found.</p>';
    return;
  }

  const list = document.createElement('div');
  list.className = 'event-list';

  for (const ev of events) {
    const card = document.createElement('article');
    card.className = 'event-card';

    const when = document.createElement('div');
    when.className = 'event-when';
    when.textContent = ev.start.toLocaleString(undefined, {
      year: 'numeric', month: 'short', day: 'numeric',
      hour: '2-digit', minute: '2-digit'
    });

    const title = document.createElement('h3');
    title.className = 'event-title';
    title.textContent = ev.title;

    const loc = document.createElement('p');
    loc.className = 'event-location';
    loc.textContent = ev.location;

    const more = document.createElement('a');
    more.className = 'btn';
    more.href = ev.link;
    more.target = '_blank';
    more.textContent = 'More info';

    card.appendChild(when);
    card.appendChild(title);
    card.appendChild(loc);
    card.appendChild(more);
    list.appendChild(card);
  }

  root.appendChild(list);
}
</script>
</body>
</html>
